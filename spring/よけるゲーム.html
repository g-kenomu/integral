<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title></title>
</head>
<body>

</body>
</html>
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>無心で避けろ！AIドッジ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Noto+Sans+JP:wght@400;900&display=swap');
        
        body { 
            font-family: 'Noto Sans JP', sans-serif;
            overflow: hidden;
            touch-action: none;
            background-color: #000;
        }

        .font-game { font-family: 'Black Ops One', cursive; }

        .neon-text {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #0ff, 0 0 30px #0ff, 0 0 40px #0ff;
        }
        
        canvas {
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .btn-start { animation: pulse-red 2s infinite; }

        /* CRT Monitor Effect */
        .scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body class="bg-black text-white h-screen w-screen flex flex-col relative">

    <div class="scanlines"></div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas" class="block w-full h-full"></canvas>

    <!-- UI Overlay: Score -->
    <div class="absolute top-4 left-4 pointer-events-none select-none z-20">
        <p class="text-xs text-slate-400 font-bold uppercase tracking-widest">SCORE</p>
        <p id="scoreDisplay" class="text-4xl font-game text-white neon-text">0</p>
        <p class="text-[10px] text-yellow-500 font-bold mt-1">BEST: <span id="bestScoreDisplay">0</span></p>
    </div>

    <!-- UI Overlay: Start Screen -->
    <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/80 z-30 backdrop-blur-sm transition-opacity duration-500">
        <h1 class="text-6xl font-game text-transparent bg-clip-text bg-gradient-to-b from-cyan-300 to-blue-600 mb-2 neon-text text-center leading-tight tracking-tighter">
            NEON<br>DODGE
        </h1>
        <p class="text-slate-400 text-sm mb-8 font-bold tracking-widest">SOUND ON RECOMMENDED</p>
        
        <button onclick="startGame()" class="btn-start bg-red-600 hover:bg-red-500 text-white font-black py-4 px-12 rounded-full text-xl tracking-wider transition-transform active:scale-95 shadow-lg shadow-red-900/50">
            PLAY
        </button>
        <p class="text-[10px] text-slate-500 mt-4">DRAG TO MOVE</p>
    </div>

    <!-- UI Overlay: Game Over Screen -->
    <div id="gameOverScreen" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-black/90 z-40 backdrop-blur-md px-6">
        <p class="text-red-500 font-game text-5xl mb-2 neon-text tracking-widest">CRASHED</p>
        
        <div class="text-center mb-6">
            <p class="text-xs text-slate-400 font-bold">FINAL SCORE</p>
            <p id="finalScore" class="text-6xl font-game text-white mb-1">0</p>
            <p id="newRecordMsg" class="text-yellow-400 font-black text-sm hidden animate-pulse">NEW RECORD!</p>
        </div>

        <!-- AI Comment Area -->
        <div class="w-full max-w-sm bg-slate-900/80 border border-slate-700 rounded-xl p-4 mb-6 relative min-h-[100px] flex items-center justify-center shadow-lg shadow-cyan-900/20">
            <div id="ai-loading" class="flex flex-col items-center gap-2">
                <div class="w-6 h-6 border-2 border-cyan-500 border-t-transparent rounded-full animate-spin"></div>
                <span class="text-xs text-cyan-500 font-bold">AI ANALYZING...</span>
            </div>
            <div id="ai-comment-box" class="hidden w-full">
                <div class="flex items-start gap-3">
                    <div class="bg-cyan-900/30 p-2 rounded-full shrink-0">
                        <i data-lucide="bot" class="w-6 h-6 text-cyan-400"></i>
                    </div>
                    <div class="text-left">
                        <p class="text-[10px] font-bold text-cyan-500 mb-1">AI COMMENT</p>
                        <p id="ai-text" class="text-sm text-slate-200 leading-relaxed font-bold"></p>
                    </div>
                </div>
            </div>
        </div>

        <button onclick="startGame()" class="bg-white text-black hover:bg-slate-200 font-black py-3 px-10 rounded-full text-lg transition-transform active:scale-95 flex items-center gap-2">
            <i data-lucide="rotate-ccw" class="w-5 h-5"></i>
            RETRY
        </button>
    </div>

    <script>
        const apiKey = "AIzaSyAQD2nlFwe1IgnERM6_DN9MgmvkjXxE1iQ";

        // --- Sound Engine (Web Audio API) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = new AudioContext();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const now = audioCtx.currentTime;

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'start') {
                // Rising Sci-fi Sound
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(220, now);
                osc.frequency.exponentialRampToValueAtTime(880, now + 0.5);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            } else if (type === 'crash') {
                // Explosion Noise-like
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
                
                // LFO for roughness
                const lfo = audioCtx.createOscillator();
                lfo.frequency.value = 50;
                lfo.connect(gain.gain);
                lfo.start(now);
                lfo.stop(now + 0.5);

                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            } else if (type === 'score') {
                // Subtle blip
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, now);
                osc.frequency.exponentialRampToValueAtTime(1760, now + 0.1);
                gain.gain.setValueAtTime(0.05, now); // Quiet
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
        }

        // --- Game Logic ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameRunning = false;
        let score = 0;
        let highScore = localStorage.getItem('neon_dodge_best') || 0;
        let difficulty = 1;
        let animationId;
        
        // Update High Score Display
        document.getElementById('bestScoreDisplay').innerText = highScore;

        // Player
        const player = {
            x: 0,
            y: 0,
            radius: 12,
            color: '#00ffff',
            trail: []
        };

        // Particles
        let particles = [];

        // Input
        let targetX = window.innerWidth / 2;
        
        // Obstacles
        let obstacles = [];
        let frameCount = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            player.y = canvas.height - 120;
        }
        window.addEventListener('resize', resize);
        resize();

        function handleInput(x) {
            targetX = x;
            if (targetX < player.radius) targetX = player.radius;
            if (targetX > canvas.width - player.radius) targetX = canvas.width - player.radius;
        }

        window.addEventListener('mousemove', e => {
            if (gameRunning) handleInput(e.clientX);
        });
        
        window.addEventListener('touchmove', e => {
            if (gameRunning) {
                e.preventDefault();
                handleInput(e.touches[0].clientX);
            }
        }, { passive: false });

        function createParticles(x, y, color) {
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color: color
                });
            }
        }

        function startGame() {
            playSound('start');
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('newRecordMsg').classList.add('hidden');
            
            gameRunning = true;
            score = 0;
            difficulty = 1;
            obstacles = [];
            particles = [];
            player.x = window.innerWidth / 2;
            player.trail = [];
            targetX = player.x;
            frameCount = 0;
            
            document.getElementById('scoreDisplay').innerText = score;
            
            if (animationId) cancelAnimationFrame(animationId);
            gameLoop();
        }

        function gameOver() {
            playSound('crash');
            gameRunning = false;
            
            // Spawn explosion where player was
            createParticles(player.x, player.y, player.color);
            
            // Run a few more frames to show explosion
            let endFrames = 0;
            function endLoop() {
                if (endFrames++ < 30) {
                    drawGame(); // Draw only, no update logic for game
                    updateParticles();
                    requestAnimationFrame(endLoop);
                } else {
                    showGameOverScreen();
                }
            }
            endLoop();
        }

        function showGameOverScreen() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('neon_dodge_best', highScore);
                document.getElementById('newRecordMsg').classList.remove('hidden');
            }
            document.getElementById('bestScoreDisplay').innerText = highScore;
            document.getElementById('finalScore').innerText = score;
            document.getElementById('gameOverScreen').classList.remove('hidden');
            
            getAIComment(score);
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            for (let p of particles) {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }

        function drawGame() {
            // Trail effect background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Particles
            drawParticles();

            // Draw Obstacles
            for (let ob of obstacles) {
                ctx.fillStyle = ob.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = ob.color;
                ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
                ctx.shadowBlur = 0;
            }

            if (gameRunning) {
                // Player Trail
                ctx.beginPath();
                if (player.trail.length > 0) {
                    ctx.moveTo(player.trail[0].x, player.trail[0].y);
                    for (let i = 1; i < player.trail.length; i++) {
                        ctx.lineTo(player.trail[i].x, player.trail[i].y);
                    }
                }
                ctx.strokeStyle = `rgba(0, 255, 255, 0.2)`;
                ctx.lineWidth = player.radius;
                ctx.lineCap = 'round';
                ctx.stroke();

                // Player Body
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#0ff';
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function gameLoop() {
            if (!gameRunning) return;

            // Logic
            difficulty = 1 + (score / 1000); // Gradual speed up

            frameCount++;
            // Dynamic spawn rate
            const spawnRate = Math.max(8, Math.floor(25 / difficulty));
            
            if (frameCount % spawnRate === 0) {
                const size = Math.random() * 40 + 20;
                obstacles.push({
                    x: Math.random() * (canvas.width - size),
                    y: -size - 20,
                    w: size,
                    h: size * (Math.random() * 1.5 + 0.5),
                    speed: (Math.random() * 3 + 4) * difficulty,
                    color: `hsl(${Math.random() * 60 + 320}, 100%, 60%)`
                });
            }

            // Update Player
            player.x += (targetX - player.x) * 0.15;
            player.trail.push({x: player.x, y: player.y});
            if (player.trail.length > 12) player.trail.shift();

            // Update Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let ob = obstacles[i];
                ob.y += ob.speed;

                // Collision
                // Simple AABB (Box) vs Circle
                // Clamping circle center to closest point in box
                let testX = player.x;
                let testY = player.y;

                if (player.x < ob.x) testX = ob.x;
                else if (player.x > ob.x + ob.w) testX = ob.x + ob.w;
                
                if (player.y < ob.y) testY = ob.y;
                else if (player.y > ob.y + ob.h) testY = ob.y + ob.h;

                let distX = player.x - testX;
                let distY = player.y - testY;
                let distance = Math.sqrt((distX * distX) + (distY * distY));

                if (distance <= player.radius - 4) { // Hit!
                    gameOver();
                    return;
                }

                // Remove & Score
                if (ob.y > canvas.height) {
                    obstacles.splice(i, 1);
                    score += 10;
                    document.getElementById('scoreDisplay').innerText = score;
                }
            }

            drawGame();
            animationId = requestAnimationFrame(gameLoop);
        }

        // --- Gemini AI ---
        async function getAIComment(finalScore) {
            const loading = document.getElementById('ai-loading');
            const commentBox = document.getElementById('ai-comment-box');
            const textEl = document.getElementById('ai-text');
            
            loading.classList.remove('hidden');
            commentBox.classList.add('hidden');

            try {
                let mood = "";
                if (finalScore < 500) {
                    mood = "あなたは煽り性能の高い毒舌AIです。プレイヤーがすぐに死んでしまったことを、皮肉たっぷりに短く煽ってください。「指ついてますか？」「まさかそれが本気？」など。";
                } else if (finalScore < 2000) {
                    mood = "あなたは厳しいコーチAIです。「悪くはないが、反射神経が足りない」というニュアンスで、上から目線で短く評価してください。";
                } else {
                    mood = "あなたは熱狂的な実況AIです。プレイヤーの驚異的なスコアを、大興奮して短く褒めちぎってください！「神がかった指さばきだ！」など。";
                }

                const prompt = `NEON DODGE Game Over. Score: ${finalScore}. ${mood} Output only one short sentence (max 40 chars). No JSON.`;

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });

                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "通信エラーだ。だが君のスコアは覚えたぞ。";
                
                textEl.innerText = text;
                loading.classList.add('hidden');
                commentBox.classList.remove('hidden');
                lucide.createIcons();

            } catch (e) {
                console.error(e);
                textEl.innerText = "通信エラー...（AIも驚くほどのスピードだったか？）";
                loading.classList.add('hidden');
                commentBox.classList.remove('hidden');
            }
        }
        
        lucide.createIcons();

    </script>
</body>
</html>